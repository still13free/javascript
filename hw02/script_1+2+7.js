/*
Задание 1

var a = 1, b = 1, c, d;
c = ++a; alert(c);           // 2   - сначала к 'a'(1) применяется инкремент, после чего новая 'a'(2) записывается в 'c'
d = b++; alert(d);           // 1   - сначала в 'd' записывается 'b'(1), затем к 'b' применяется инкремент (b=2)
c = (2+ ++a); alert(c);      // 5   - сначала к 'a'(2) применяется инкремент, выполняется сложение 2 и новой 'a'(3), а результат записывается в 'c'
d = (2+ b++); alert(d);      // 4   - сначала в 'd' записывается результат сложения 2 и 'b'(2), затем к 'b' применяется инкремент (b=3)
alert(a);                    // 3
alert(b);                    // 3



Задание 2

var a = 2;
var x = 1 + (a *= 2);

сначала обновится значение 'a' = a * 2 = 2 * 2 = 4, после чего в 'x' запишется результат сложения
*/



//Задание 7 Сравнить null и 0
console.log(null < 0)       // false
console.log(null > 0)       // false
console.log(null <= 0)      // true
console.log(null >= 0)      // true
console.log(null == 0)      // false
console.log(null != 0)      // true
console.log(null === 0)     // false
console.log(null !== 0)     // true

/*
Условно назовём сравнения больше(>), меньше(<) и равно(==, ===) простыми
А сравнения меньше или равно(<=), большие или равно(>=) и не равно(!=, !==) обратными соответственно
Тип null обозначает несуществующий объект, в то время как 0 можно назвать объектом типа Number
Но сравнить ничто с чем-то невозможно, поэтому простые сравнения принимают значения false
Обратные же сравнения в таком случае принимают true,
поскольку нет необходимости производить два сравнения (< и ==) и находить результат логическим И,
а всего лишь достаточно взять обратное значение сравнения >, которое как раз равно false
Для неравеств же (!=, !==) аналогично: если равенство false, то неравенство true
Это логично само по себе: ничто не может равняться чему-то

Хотя статья на хабре выносит мозг :) ощущение, что когда писались эти алгоритмы, никто и не думал о сравнение null и 0
*/